;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(+ 1 2)" "'+" "+" "(r-print 34)" "(r-print \"Helloooo\")" "(macroexpand '(special-print 34))" "(special-print 34)" "(special-print)" "(macroexpand '(special-print :f \"sdfss\" 34))" "(special-print :f \"dsdfw\" 34)" "(special-print \"3ewf\")" "(special-print 23)" "(special-print)" "(special-print 34 \"Hey\")" "(special-print 34)" "(special-print)" "(infix-3 (1 + 9))" "(infix-2 (1 + 3))" "(macroexpand '(when (true) (+ 1 2) (+ 3 4)))" "(infix (1 + 2))" "(macroexpand '(ignore-last (+ 1 2 3)))" "(ignore-last (+ 1 2 3 4 5 (println \"HEE\")))" "(ignore-last (+ 1 2 3 4 5 6))" "(def sdfsdf inc)" "(def mcdcd 23)" "(def myif if)" "()" ":k" "{:k 10}" "{}" "12/3" "343" "false" "true" "(read-string \"; ignore!\\n(+ 1 2)\")" "(read-string \"#(+ 1 %)\")" "(read-string \"heellooeeee\")" "(read-string \"{:k \\\"def\\\"}\")" "(read-string \"[1 2 3 4]\")" "(read-string \"str\")" "(doc list?)" "(eval (read-string \"(+ 1 2)\"))" "(read-string \"(+ 1 2)\")" "(doc read-string)" "(str \"A\" \"B\" \"C\")" "(eval '(if (true) \"Yes\" \"No\"))" "(doc eval)" "(eval '(1 2 3 4 5))" "(eval '(+ 1 2 3 4 5))" "(list + 1 2 3 4)" "(list 3 4 5 6)" "(backwards (\" backwards\" \" am\" \"I\" str))" "(= -> ->>)" "(doc ->>)" "(doc ->)" "(doc refer)" "A" "(in-ns 'braveclojure.core)" "(inc 2)" "(in-ns 'data.lib)" "(ns-map 'data.lib)" "(ns-interns 'data.lib)" "(create-ns 'data.lib)" "A" "(def A \"Hello Eric\")" "A" "(def A \"Hello World\")" "A" "(def A \"Hello World\")" "map" "(deref #'braveclojure.core/parse)" "(ns-interns *ns*)" "(deref #'braveclojure.core/days)" "(ns-map *ns*)" "(doc ns-map)" "(get (ns-interns *ns*) 'days)" "(doc ns-interns)" "(ns-interns *ns*)" "(doc ns-interns)" "(get-interns *ns*)" "'inc" "34" "inc" "*ns*" "(doc ns-name)" "(apply str (reduce #(conj %1 %2) '() \"\"))" "(apply str (reduce #(conj %1 %2) '() \"Hello World\"))" "(reduce #(conj %1 %2) '() \"Hello World\")" "(reduce #(conj %2 %1) '() \"Hello World\")" "(reduce conj \"Hello World !\")" "(memoized-hello \"Eric\")" "(memoized-hello \"Jose\")" "(memoized-hello \"Eric\")" "(sleepy-hello \"Eric\")" "(sleepy-hello \"Jose\")" "(sleepy-hello \"Eric\")" "((my-comp inc inc inc inc *) 2 5)" "((my-comp inc *) 2 3)" "(clean \" dfgdf sdfs lol dfs lol!!    \")" "(my-sum-with-recur [1 2 3 4 5 6])" "(my-sum [1 2 3 4 5 6])" "(glitter-filter 3 (mapify (parse (slurp filename))))" "clear" "(mapify (parse (slurp filename)))" "(map vector vamp-keys [\"Eric\" \"10\"])" "(parse (slurp filename))" "(clojure.string/split (slurp filename) #\"\\n\")" "(slurp filename)" "(parse (slurp filename))" "(convert :glitter-index \"34\")" "(convert :name \"Eric\")" "(Integer. \"23\")" "(doc slurp)" "(slurp filename)" "((complement even?) 2)" "(not false)" "(not true)" ")" "(f1 [11 12 13 14])" "(f1 [1 2 3 4])" "(f0 [11 12 13 14])" "(f0 [1 2 3 4])" "(def f1 (partial f0 100))" "(def f0 (partial apply max 10 9 8))" "(x1 [11 0 0 0])" "(x1 [1 2 3 4])" "(def x1 (partial x 7))" "(def x (partial apply max 10 9 8))" "(def x1 ((partial apply max 1 2 3 40 5)))" "((partial + 1 2 3 4 5) 5)" "(apply max 1 2 3 4 5)" "(apply max 45 '(1 2 3 4 5))" "(apply + 1 2 [3 4 5])" "(apply + 1 [2] [3 4] 5)" "(apply + 1 [2] [3 4] #{5})" "(apply max 1 2 [3 4])" "(doc apply)" "(apply + (hash-set 1 2 3 4  5 5 5 6 6 78))" "(hash-set 1 2 3 4  666 7)" "(set 1 2 3 33 4)" "(map #(apply % [1 2 3 4 5]) [+ *])" "(max  545 646 7 5  6 43 4 23 42 342)" "(conj '() {} :d [1 2 3 4])" "(conj [1 2 3 4] 1 2)" "(conj [1 2 3] 45)" "(doc into)" "(into '() [1 2 3 4 5])" "(into #{} (map identity [1 2 3 4 5]))" "(into [] [1 2 3 4])" "(doc lazy-seq)" "(lazy-seq [1 2 3] [4 5 6])" "(lazy-seq [1 2 3] '(1 2 3))" "(lazy-seq 1 2 3 4 5)" "(doc lazy-seq)" "(take 10 (repeatedly #(rand-int 20)))" "(repeat 0)" "(time (first [1 2 3 4]))" "(range \\a \\z)" "(range 0 10)" "mres" "(seq? mres)" "(def mres (map #(do (println %) (+ 1 %)) [1 2 3 4 5]))" "(map #(do (println %) (+ 1 %)) [1 2 3 4 5])" "(concat [1 2 3 4] {:a 34 :b 34 :c 45})" "(concat [1 2 3] [4 5])" "(sort-by :age {:n \"Eric\" :age 30 :n \"Javier\" :age 31 :n \"Pedro\" :age 79})" "(sort [ 6 345 3 45 34 53])" "(some #(if (even? %) % false) [1 2 3 4])" "(some even? [1 2 3 4])" "(some even? [1 3 5 7])" "(map + [1 2 3] [3 2 1])" "(seq #{ 1 2 })" "(seq \"Hello\")" "(seq {})" "(cons \\H \"ello\")" "(map inc \"Hello\")" "(map (+ 1) \"Hello\")" "(rest \"Hello\")" "(first \"Hello\")" "(hit asym-hobbit-body-parts)" "(better-symmetrize-body-parts asym-hobbit-body-parts)" "(reduce + [1 2 3 4 5])" "(clojure.string/replace \"Hello World!!\" #\"o\" \"A\")" "(loop [it 0] (println it) (if (> it 3) (println \"Bye\") (recur (inc it))))" "(into [] {:a 34})" "(into {:a 34} {:b 35})" "(into {} {:a 34})" "(into [1 2 3] [4 5 6])" "(into [] [4])" "(doc into)" "(into [] 23)" "(into [] a)" "(into {} [:d 34])" "(let [{:keys [a b c d]} {:a 1 :aa 2 :b 3 :bb 4 :c 5 :d 6}] (+ a b c d))" "(let [{:keys [a b c d]} {:a 1 :aa 2 :b 3 :bb 4 :c 5 :d 6}] a + b + c + d)" "(let [x 3 y 5] (+ x y))" "(symmetrize-body-parts asym-hobbit-body-parts)" "(do (future (Thread/sleep 4000) (println \"I will print after 4 seconds\")) (println \"I will print inmediatelly\"))" "(nil? (if true \"Hello\"))" "(nil? (if false \"Hello\"))" "(nil? nil)" "(nil? 450)" "34 + 45" "45" "(two-fer/two-fer \"Julia\")" "(two-fer/two-fer)" "(two-fer/two-fer \"Eric\")" "(two-fer/two-fer)")